说到线程同步这块：涉及到这两个专业术语:
  异步编程：
    线程1和线程2，各自执行各自的，t1不管t2,t2不管t1,谁也不需要等谁
    ，这种编程模型叫做：异步编程模型，
    其实就是：多线程并发(效率高)

  同步编程：
    线程1和线程2，在线程1执行的时候，必须等待线程2执行结束，或者说在t2线程执行的时候，必须等待
    线程1执行结束，两个线程之间发生了等待关系，这就是同步编程模型，效率较低，线程排队执行
    同步就是排队。

    Java中有三大变量？？？
    实例变量，成员变量  堆中
    静态变量     在方法区中
    局部变量      在栈中

    一个进程一个堆和一个方法区，一个进程多个线程，一个线程一个栈。
    堆和方法区中的数据是和所有线程共享的数据。

    以上三大变量中：
      局部变量永远都不会存在线程安全问题的是: 局部变量
        因为局部变量存在栈中(一个线程一个栈)，是每个线程各自独立拥有的，不会共享

    实例变量在堆中，堆只有一个
    静态变量在方法区中，方法区只有一个，
    一个进程一个堆一个方法区，所有多线程共享的，所有有可能存在线程的安全问题。



    在实例方法上可以使用synchronized 吗？ 可以的
      synchronized 出现在实例方法上，一定锁的是 this,
      而如果是静态方法的话就是 类.class 类锁了
      没得选，这些都是默认的。

      另外还有一个缺点：synchronized 出现在实例方法上，表示整个方法体
      ，表示整个方法体都需要同步，可能会无故扩大同步的范围，导致程序的执行效率降低。


      如果使用局部变量的话：
      建议使用 StringBuilder
      因为局部变量不存在线程安全问题，选择StringBuilder  更合适
      StringBuffer 效率比较低，因为进行了 synchronized 的处理

      ArrayList 是非线程安全的
      Vector 是线程安全的
      HashMap HashSet 是非线程安全的
      Hashtable 是线程安全的



      synchronized 有三种写法
       第一种: 同步代码块：
        灵活
          synchronized (线程共享对象) {
             同步代码
          }

        第二种:同步方法:
         在实例方法上使用； synchronized
          表示共享对象一定是 this
          并且同步代码块是整个方法体
        第三种：静态方法上使用: synchronized 表示类锁，
        类锁永远只有一把，因为类仅仅只会加载一次，所有对象共用
        就算创建100个对象，那类锁也只有一把。

        对象锁：1个对象1把锁，100个对象可以有100把锁
        类锁：100个对象，也只有一把类锁


        1.线程这块还有哪些内容呢？列举一下：
         > 守护线程
           java语言中线程分为两大类
             一类是：用户线程
             一类是：守护线程(后台线程)
            其中具有代表性的就是：垃圾回收线程(守护线程)

            守护线程的特点:
             一般守护线程就是一个死循环，所有的用户线程只要结束。
             守护线程自动结束。

            注意：主线程main方法是一个用户线程。

            守护线程用在什么地方呢
             每天 0:00 的时候，系统数据自动备份。
             这个需要使用到定时器，并且我们可以将定时器设置为守护线程，
             一直在哪里看着，每到 0.00的时候就备份一次。
             所有的用户线程如果结束了，守护线程自动退出，没有必要进行数据备份了。



     关于Object 类中的wait和notify方法（生产者和消费者模式）

     第一: wait 和 notify方法不是线程对象的方法，是java中任何一个java对象
         都有的方法，因为这两个方式是Object类中自带的.
         wait方法和 notify()方法不是通过线程对象调用的。
         不是这样的,t.wait(),也不是这样的,t.notify()，不对》
      第二: wait()方法作用?
      Object o = new Object();

      o.wait();

      表示:
        让正在O对象上活动的线程进入等待状态。
        直到被唤醒为止。
        o.wait()方法的调用,会让"当前线程(正在O对象上活动的线程)" 进入等待状态.并释放手中的锁

      第三: notify()方法作用:
      Object o = new Object();
      o.notify()
      表示唤醒正在 o对象上等待的线程
      还有一个notifyAll()方法：
         这个方法是唤醒o对象上处于等待的所有线程。




