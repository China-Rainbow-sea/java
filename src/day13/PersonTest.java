package day13;


/*
方法的重写(覆盖): override / overwrite
1. 重写: 子类继承父类以后,可以对父类中 “同名同参数”的方法，进行覆盖操作.
2. 应用: 子类重写父类以后: 当创建子类对象以后,通过子类对象调用父类同名同参数的方法时，实际执行的是子类重写(覆盖)父类的方法
3.重写的规定:
         方法的声明：权限修饰符 返回值类型 方法名(形参列表) {
                    // 方法体
         }

       约定俗称: 子类中的叫重写的方法，父类中的叫被重写的方法
       1. 子类重写的方法的 “方法名”和“形参列表” 与父类被重写的方法的 “方法名”和“形参列表” 必须相同一致。
       这两者之间如有一个地方不同就不是 “重写” 而是各自子父类独自的方法。
       2. 子类重写的方法的权限修饰符 >= 父类被重写的方法的权限修饰符.因为子类想要覆盖掉父类中的方法,其权限修饰符是不是要>= 父类才可以被覆盖掉
       如果父类的权限修饰符 > 子类的权限修饰符，那还怎么实现覆盖的行为.
        > 特殊情况: 父类的修饰符为 public 子类必须是 public 因为想要实现子类重写/覆盖父类方法,权限修饰符必须 >= 父类的权限修饰符，
                   而public 是最大的权限修饰符了，没有更大的了,所以子类想要重写/覆盖父类的方法就只能 “==” 父类的权限修饰符了。
                    父类的权限修饰符为 private(私有)的时候,子类是不可以重写该方法的,因为这是私有的,
                    子类虽然继承了，但是子类没有权限访问，重写覆盖。
                    虽然子类中实现了和父类被private一样的方法但是(所达到的效果是子类自己独有的方法而已但是并没有重写父类中private的方法)\
         返回值类型：
            父类被重写的方法的返回值类型是void ,则子类重写的方法的返回值类型只能是 void
            父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型也必须是A类型或者是A类型的子类。
            父类被重写的方法的返回类型是基本数据类型，则子类重写的方法的返回值类型也必须是相同的基本数据类型.
            比如: 父类返回的数据类型是 double,想要重写/覆盖父类中的方法,则子类必须也是double 类型才可以,int是不行的
            // double 到 int 类型是不一样的类型,只是存在一个类型的转换而已.
            子类重写的方法抛出的异常类型 <= 父类被重写的方法抛出的异常类型.
            子类和父类中的同名同参数，同返回类型,要么都声明为static 静态方法,要么都声明为非static静态方法.
            而静态方法的static 是不可以重写的.
            只有方法可以重写，属性是不可以重写的.



*/
public class PersonTest {
    public static void main(String[] args) {
        Student student = new Student("计算机科学与技术");

        student.eat();   // 调用子类重写后父类的方法;
        student.walk(10);  // 子类没有重写父类中的方法,调用父类的方法
        student.study();    // 子类特有的方法
        student.show();
        student.test();

        System.out.println("***********************************");

        Person person  = new Person();
        person.eat();
        person.show();

    }
}
